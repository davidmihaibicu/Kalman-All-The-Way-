-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\EkalmanF_ac_sim\MATLAB_Function.vhd
-- Created: 2026-01-12 14:16:47
-- 
-- Generated by MATLAB 25.2, HDL Coder 25.2, and Simulink 25.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: MATLAB_Function
-- Source Path: EkalmanF_ac_sim/EKF/Predict/MATLAB Function
-- Hierarchy Level: 2
-- Model version: 1.76
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.EKF_pkg.ALL;

ENTITY MATLAB_Function IS
  PORT( x_est                             :   IN    vector_of_std_logic_vector32(0 TO 3);  -- sfix32_En20 [4]
        dt                                :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En20
        fx                                :   OUT   vector_of_std_logic_vector32(0 TO 3)  -- sfix32_En20 [4]
        );
END MATLAB_Function;


ARCHITECTURE rtl OF MATLAB_Function IS

  -- Signals
  SIGNAL x_est_signed                     : vector_of_signed32(0 TO 3);  -- sfix32_En20 [4]
  SIGNAL dt_signed                        : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL fx_tmp                           : vector_of_signed32(0 TO 3);  -- sfix32_En20 [4]

BEGIN
  outputgen1: FOR k IN 0 TO 3 GENERATE
    x_est_signed(k) <= signed(x_est(k));
  END GENERATE;

  dt_signed <= signed(dt);

  MATLAB_Function_1_output : PROCESS (dt_signed, x_est_signed)
    VARIABLE sin_val : signed(31 DOWNTO 0);
    VARIABLE term_dt : signed(31 DOWNTO 0);
    VARIABLE term_sin : signed(31 DOWNTO 0);
    VARIABLE x_est1 : vector_of_signed32(0 TO 3);
    VARIABLE theta_sq : signed(31 DOWNTO 0);
    VARIABLE inner_term : signed(31 DOWNTO 0);
    VARIABLE mid_term : signed(31 DOWNTO 0);
    VARIABLE mul_temp : signed(63 DOWNTO 0);
    VARIABLE mul_temp_0 : signed(63 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(32 DOWNTO 0);
    VARIABLE sub_temp : signed(32 DOWNTO 0);
    VARIABLE mul_temp_1 : signed(63 DOWNTO 0);
    VARIABLE sub_cast_1 : signed(31 DOWNTO 0);
    VARIABLE sub_cast_2 : signed(32 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(32 DOWNTO 0);
    VARIABLE mul_temp_2 : signed(63 DOWNTO 0);
    VARIABLE mul_temp_3 : signed(63 DOWNTO 0);
    VARIABLE mul_temp_4 : signed(63 DOWNTO 0);
    VARIABLE add_cast : signed(31 DOWNTO 0);
    VARIABLE add_cast_0 : signed(32 DOWNTO 0);
    VARIABLE add_cast_1 : signed(32 DOWNTO 0);
    VARIABLE add_temp : signed(32 DOWNTO 0);
    VARIABLE add_cast_2 : signed(31 DOWNTO 0);
    VARIABLE add_cast_3 : signed(32 DOWNTO 0);
    VARIABLE add_cast_4 : signed(32 DOWNTO 0);
    VARIABLE add_temp_0 : signed(32 DOWNTO 0);
    VARIABLE cast : signed(31 DOWNTO 0);
  BEGIN
    mul_temp := to_signed(0, 64);
    mul_temp_0 := to_signed(0, 64);
    sub_temp := to_signed(0, 33);
    mul_temp_1 := to_signed(0, 64);
    sub_temp_0 := to_signed(0, 33);
    mul_temp_2 := to_signed(0, 64);
    mul_temp_3 := to_signed(0, 64);
    mul_temp_4 := to_signed(0, 64);
    add_temp := to_signed(0, 33);
    add_temp_0 := to_signed(0, 33);
    theta_sq := to_signed(0, 32);
    sub_cast := to_signed(0, 32);
    sub_cast_0 := to_signed(0, 33);
    inner_term := to_signed(0, 32);
    sub_cast_1 := to_signed(0, 32);
    sub_cast_2 := to_signed(0, 33);
    mid_term := to_signed(0, 32);
    sin_val := to_signed(0, 32);
    term_dt := to_signed(0, 32);
    term_sin := to_signed(0, 32);
    add_cast := to_signed(0, 32);
    add_cast_0 := to_signed(0, 33);
    add_cast_1 := to_signed(0, 33);
    add_cast_2 := to_signed(0, 32);
    add_cast_3 := to_signed(0, 33);
    add_cast_4 := to_signed(0, 33);
    cast := to_signed(0, 32);
    -- 1. Define Fixed-Point Math Properties
    -- CRITICAL: 'Saturate' is safer for control systems than 'Wrap'.
    -- We use 'KeepLSB' or specific lengths to prevent bit-width explosion.
    -- Apply fimath to inputs to ensure internal ops use these rules

    FOR t_0 IN 0 TO 3 LOOP
      x_est1(t_0) := x_est_signed(t_0);
    END LOOP;

    -- 2. Pre-allocate output
    -- 3. Constants
    -- 4. Compute State Equations
    -- We process indices 1 and 2 in a loop. HDL Coder can interpret this 
    -- to either share resources (save space) or unroll (save time).

    FOR i IN 0 TO 1 LOOP
      -- Calculate Sine Term using optimized function
      -- --- SUB-FUNCTION: Optimized Sine (Horner's Method) ---
      -- Uses Horner's Rule to reduce the number of multipliers.
      -- Original: x - c2*x^3 + c3*x^5
      -- Horner's: x * (1 - x^2 * (c2 - c3*x^2))
      -- Define coefficients
      -- c2 = 1/6  = 0.16666666...
      -- c3 = 1/120 = 0.00833333...
      -- 1. Calculate x^2 once
      mul_temp := x_est1(i) * x_est1(i);
      IF (mul_temp(63) = '0') AND (mul_temp(62 DOWNTO 47) /= X"0000") THEN 
        theta_sq := X"7FFFFFFF";
      ELSIF (mul_temp(63) = '1') AND (mul_temp(62 DOWNTO 47) /= X"FFFF") THEN 
        theta_sq := X"80000000";
      ELSE 
        theta_sq := mul_temp(47 DOWNTO 16);
      END IF;
      -- 2. Inner term: (c2 - c3 * theta^2)
      mul_temp_0 := to_signed(8738, 32) * theta_sq;
      IF (mul_temp_0(63) = '0') AND (mul_temp_0(62 DOWNTO 51) /= "000000000000") THEN 
        sub_cast := X"7FFFFFFF";
      ELSIF (mul_temp_0(63) = '1') AND (mul_temp_0(62 DOWNTO 51) /= "111111111111") THEN 
        sub_cast := X"80000000";
      ELSE 
        sub_cast := mul_temp_0(51 DOWNTO 20);
      END IF;
      sub_cast_0 := resize(sub_cast, 33);
      sub_temp := to_signed(2796192, 33) - sub_cast_0;
      IF (sub_temp(32) = '0') AND (sub_temp(31) /= '0') THEN 
        inner_term := X"7FFFFFFF";
      ELSIF (sub_temp(32) = '1') AND (sub_temp(31) /= '1') THEN 
        inner_term := X"80000000";
      ELSE 
        inner_term := sub_temp(31 DOWNTO 0);
      END IF;
      -- 3. Middle term: 1 - theta^2 * (inner)
      mul_temp_1 := theta_sq * inner_term;
      IF (mul_temp_1(63) = '0') AND (mul_temp_1(62 DOWNTO 55) /= "00000000") THEN 
        sub_cast_1 := X"7FFFFFFF";
      ELSIF (mul_temp_1(63) = '1') AND (mul_temp_1(62 DOWNTO 55) /= "11111111") THEN 
        sub_cast_1 := X"80000000";
      ELSE 
        sub_cast_1 := mul_temp_1(55 DOWNTO 24);
      END IF;
      sub_cast_2 := resize(sub_cast_1, 33);
      sub_temp_0 := to_signed(16777216, 33) - sub_cast_2;
      IF (sub_temp_0(32) = '0') AND (sub_temp_0(31) /= '0') THEN 
        mid_term := X"7FFFFFFF";
      ELSIF (sub_temp_0(32) = '1') AND (sub_temp_0(31) /= '1') THEN 
        mid_term := X"80000000";
      ELSE 
        mid_term := sub_temp_0(31 DOWNTO 0);
      END IF;
      -- 4. Final result: theta * mid_term
      mul_temp_2 := x_est1(i) * mid_term;
      IF (mul_temp_2(63) = '0') AND (mul_temp_2(62 DOWNTO 51) /= "000000000000") THEN 
        sin_val := X"7FFFFFFF";
      ELSIF (mul_temp_2(63) = '1') AND (mul_temp_2(62 DOWNTO 51) /= "111111111111") THEN 
        sin_val := X"80000000";
      ELSE 
        sin_val := mul_temp_2(51 DOWNTO 20);
      END IF;
      -- x[k] + x[k+2]*dt + 0.3*sin(x[k])
      -- Note: explicitly casting the multiply result helps HDL Coder
      mul_temp_3 := x_est1(i + 2) * dt_signed;
      IF (mul_temp_3(63) = '0') AND (mul_temp_3(62 DOWNTO 47) /= X"0000") THEN 
        term_dt := X"7FFFFFFF";
      ELSIF (mul_temp_3(63) = '1') AND (mul_temp_3(62 DOWNTO 47) /= X"FFFF") THEN 
        term_dt := X"80000000";
      ELSE 
        term_dt := mul_temp_3(47 DOWNTO 16);
      END IF;
      mul_temp_4 := to_signed(314572, 32) * sin_val;
      IF (mul_temp_4(63) = '0') AND (mul_temp_4(62 DOWNTO 51) /= "000000000000") THEN 
        term_sin := X"7FFFFFFF";
      ELSIF (mul_temp_4(63) = '1') AND (mul_temp_4(62 DOWNTO 51) /= "111111111111") THEN 
        term_sin := X"80000000";
      ELSE 
        term_sin := mul_temp_4(51 DOWNTO 20);
      END IF;
      IF (x_est1(i)(31) = '0') AND (x_est1(i)(30 DOWNTO 27) /= "0000") THEN 
        add_cast := X"7FFFFFFF";
      ELSIF (x_est1(i)(31) = '1') AND (x_est1(i)(30 DOWNTO 27) /= "1111") THEN 
        add_cast := X"80000000";
      ELSE 
        add_cast := x_est1(i)(27 DOWNTO 0) & '0' & '0' & '0' & '0';
      END IF;
      add_cast_0 := resize(add_cast, 33);
      add_cast_1 := resize(term_dt, 33);
      add_temp := add_cast_0 + add_cast_1;
      IF (add_temp(32) = '0') AND (add_temp(31) /= '0') THEN 
        add_cast_2 := X"7FFFFFFF";
      ELSIF (add_temp(32) = '1') AND (add_temp(31) /= '1') THEN 
        add_cast_2 := X"80000000";
      ELSE 
        add_cast_2 := add_temp(31 DOWNTO 0);
      END IF;
      add_cast_3 := resize(add_cast_2, 33);
      add_cast_4 := resize(term_sin, 33);
      add_temp_0 := add_cast_3 + add_cast_4;
      IF (add_temp_0(32) = '0') AND (add_temp_0(31) /= '0') THEN 
        cast := X"7FFFFFFF";
      ELSIF (add_temp_0(32) = '1') AND (add_temp_0(31) /= '1') THEN 
        cast := X"80000000";
      ELSE 
        cast := add_temp_0(31 DOWNTO 0);
      END IF;
      fx_tmp(i) <= resize(cast(31 DOWNTO 4), 32);
    END LOOP;

    -- Pass through remaining states
    fx_tmp(2) <= x_est1(2);
    fx_tmp(3) <= x_est1(3);
  END PROCESS MATLAB_Function_1_output;


  outputgen: FOR k IN 0 TO 3 GENERATE
    fx(k) <= std_logic_vector(fx_tmp(k));
  END GENERATE;

END rtl;

